#include <iostream>
#include <iomanip>
#include <vector>
#include <fstream>
#include "Simulator.h"

/**
 * @brief: 
 *         Entry point for the Drone Swarm Formation Control Simulation.
 *
 * This program:
 * 1. Creates a 2D physics world with gravity and boundaries.
 * 2. Instantiates a Simulator that manages drones and communication.
 * 3. Spawns four drones at different corners of the world.
 * 4. Assigns each drone a target offset relative to a formation center.
 * 5. Uses a PD controller to guide drones into formation.
 * 6. Logs drone trajectory data to CSV each timestep.
 * 7. Prints communication network statistics at the end.
 *
 * The simulation demonstrates:
 * - Physics integration
 * - Multi-agent control (formation flight)
 * - Network communication (latency, jitter, drops, encryption)
 * - Telemetry logging (CSV for visualization)
 *
 * Output files:
 * - simulation_log.csv   : Drone positions/velocities over time.
 * - comms_log.csv        : All network events (generated by Network).
 */

int main() {

    // WORLD AND SIMULATOR SETUP

    World world(Vector2(0.0, -9.8), 100.0, 100.0);
    Simulator sim(world);

     // DRONE PHYSICAL PARAMETERS

    DroneParams params;
    params.mass = 1.0;         // kg
    params.maxThrust = 40.0;   // Maximum thrust force avaliable
    params.maxSpeed = 25.0;    // Speed limit used in drone physics.

    // Starting position: Corners of the World.
    std::vector<Vector2> startPositions = {
        Vector2(10.0, 10.0),
        Vector2(90.0, 10.0),
        Vector2(10.0, 90.0),
        Vector2(90.0, 90.0)
    };

    std::vector<int> droneIds;
    for (const auto& startPos : startPositions) {
        int id = sim.addDrone(params, startPos);
        droneIds.push_back(id);
    }

    // FORMATION GEOMETRY (CENTER + PER-DRONE OFFSET)
    Vector2 formationCenter(60.0, 60.0);
    std::vector<Vector2> offsets = {
        Vector2(-5.0,  0.0),  // Drone 0 target = (55, 60)
        Vector2(5.0,  0.0),   // Drone 1 target = (65, 60)
        Vector2(0.0,  5.0),   // Drone 2 target = (60, 65)
        Vector2(0.0, -5.0)    // Drone 3 target = (60, 55)
    };

    // SIMULATION PARAMETERS
    double dt = 0.01;            // Time step in seconds
    double totalTime = 0.0;      // Simulation clock
    double simDuration = 10.0;   // Total runtime
    double stopRadius = 1.5;     // Distance considered "close enough" to objective

    // PD Control gains
    double kP = 0.4;    // Proportional gain
    double kD = 1.2;    // Derivative gain

    std::cout << std::fixed << std::setprecision(3);

    // OPEN CSV LOG FILE
    std::ofstream logFile("simulation_log.csv");
    if (!logFile) {
        std::cerr << "Error: could not open simulation_log.csv for writing\n";
        return 1;
    }

    // CSV HEADER
    logFile << "time,droneId,x,y,vx,vy\n";

    // MAIN SIMULATION LOOP

    while (totalTime < simDuration) {
        const auto& drones = sim.getDrones();

        // CONTROL STEP
        for (size_t i = 0; i < droneIds.size(); ++i) {
            int id = droneIds[i];
            const Drone& d = drones[id];

            Vector2 pos = d.getPosition();
            Vector2 vel = d.getVelocity();

            // Target for this drone = formation center + its offset
            Vector2 target(
                formationCenter.x + offsets[i].x,
                formationCenter.y + offsets[i].y
            );

            Vector2 toTarget(target.x - pos.x, target.y - pos.y);
            double dist = toTarget.length();

            if (dist > stopRadius) {
                // PD acceleration command
                Vector2 accCmd = toTarget * kP - vel * kD;
                // Convert acceleration to force = m*a subtract gravity
                Vector2 desiredForce = accCmd * params.mass - world.gravity * params.mass;
                sim.setDroneThrustForce(id, desiredForce);
            }
            else {
                sim.clearDroneThrust(id);
            }
        }

        // PHYSICS + NETWORK
        sim.step(dt);
        totalTime += dt;

        // LOG STATE
        const auto& dState = sim.getDrones();
        for (size_t i = 0; i < droneIds.size(); ++i) {
            int id = droneIds[i];
            const Vector2& p = dState[id].getPosition();
            const Vector2& v = dState[id].getVelocity();

            logFile << totalTime << ","
                << id << ","
                << p.x << ","
                << p.y << ","
                << v.x << ","
                << v.y << "\n";
        }

        if (static_cast<int>(totalTime * 100) % 50 == 0) {
            std::cout << "t=" << totalTime << "\n";
            for (size_t i = 0; i < droneIds.size(); ++i) {
                int id = droneIds[i];
                const Vector2& p = dState[id].getPosition();
                const Vector2& v = dState[id].getVelocity();

                Vector2 target(
                    formationCenter.x + offsets[i].x,
                    formationCenter.y + offsets[i].y
                );
                Vector2 toTarget(target.x - p.x, target.y - p.y);
                double dist = toTarget.length();

                std::cout << "  Drone " << id
                    << " pos=(" << p.x << ", " << p.y << ")"
                    << " vel=(" << v.x << ", " << v.y << ")"
                    << " distToTarget=" << dist << "\n";
            }
            std::cout << "\n";
        }
    }

    logFile.close();

    // PRINY FINAL COMMUNICATION STATISTICS
    sim.printCommsSummary();

    std::cout << "\nSimulation complete. Press Enter to exit.\n";
    std::cin.get();

    return 0;
}
